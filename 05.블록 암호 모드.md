# (2 v s3, 3 vs 4, 4 vs 5, 5 vs 6끼리만 비교함)

# 스트림 암호의 특징을 갖는 블록 암호: 4, 5, 6

# 암호화와 복호화 구조가 같은 것 : 5, 6

# 1. 블록 암호 모드

## 1.1 블록 암호와 스트림 암호

블록 암호 -특정 비트 수의 집합을 한번에 처리하는 암호 알고리즘.
이 집합을 블록이라고 부른다. -블록 길이 : 블록의 비트 수
DES & 트리플 DES 블록 길이 : 64비트
DES: 64비트 평문, 64비트 암호문
AES: 블록 길이 128비트, 192비트, 256비트
스트림 암호 -데이터의 흐름(스트림)을 순차적으로 처리하는 암호 알고리즘.
-1비트, 8비트, 혹은 32비트 단위로 암복호화

## 1.2 모드란?

- 긴 평문을 블록으로 나누어 암호화
- 각 블록에 암호 알고리즘을 반복해서 사용하여 긴 평문 전체를 암호화
  가장 대표적인 5가지 모드만 살펴볼 것임.

1. 기본적인 원리 2. 어떤 문제가 발생할 수 있을지 3. 어떤 공격이 가능할지 4. 문제점과 공격에 대해서 어떻게 해결할지
   한글보다는 영어 풀네임이 뭔지를 기억하는게 좋음
   ECB 모드 : Electronic CodeBook Mode
   CBC 모드 : Cipher Block Chaining Mode
   CFB 모드 : Cipher-Feedback Mode
   OFB 모드 : Output-Feedback Mode
   CTR 모드 : CounTeR Mode

## 1.3 평문 블록과 암호문 블록

너무 당연한 내용...

## 1.4 적극적인 공격자 멜로리

-도청 : 소극적인 공격 -위장 : 적극적인 공격. 피해가 바로 오기 때문. -변조 : 내용을 변경하는 것. 적극적인 공격. 바로 영향을 줌. -적극적 공격자 : 멜로리
소극적 공격과 적극적 공격의 차이 : 적극적 공격은 바로 피해가 옴.

# 2. ECB 모드

## 2.1 ECB 모드란?

- 평문 블록을 암호화한 것이 그대로 암호문 블록
- 패딩 : 마지막 평문 블록이 블록 길이에 미치지 못할 때, 블록 길이에 맞춰서 빈 공간을 채우는 것.
- ECB 모드에 의한 암호화
- ECB 모드에 의한 복호화

## 2.2 ECB 모드의 특징

- 5가지 모드 중 기밀성이 가장 낮은 모드(그냥 봐도 특별한 게 없기 때문)
- 다른 모드에 비해 암호문을 살펴보는 것만으로도 평문 속의 패턴 반복성을 감지 가능(100%는 아니지만)
- 그래서 안전하지 않음

## 2.3 ECB 모드에 대한 공격

시나리오: 앨리스가 밥에게 계좌로 1억을 입금해달라는 메시지를 보내고 싶다.
메시지는 3개의 블록으로 구성되어 있다.
블록1 = 보내는 사람의 계좌번호
블록2 = 받는 사람의 계좌번호
블록3 = 입금할 금액
송금 의뢰 데이터를 받은 은행은 지정된 금액을 송금자로부터
송금처의 계좌로 이동시킴
A-5374의 계좌로부터 B-6671의 계좌로 1억 원을 송금하
라는 송금 의뢰 데이터를 만들어보자.
각각을 암호화 했으므로 송금자, 송금처, 송금액이 무엇인지 알 수 없다.
공격자 멜로리가 암호문 블록1과 블록2 내용을 바꾼다.
은행이 이것을 복호화하면 송금자가 B-6671이고 송금처가 A-5374인 것으로 변조된다.
암호문을 조작하는 것은 불법적인 행위임(당연히)
-9장에서 메시지 인증 코드를 배우는데 이를 ECB 모드와 같이 사용하면 암호문 조작 문제는 막을 수 있음. 일단은 지금은 어쨌든 ECB 모드만을 사용하면 문제점이 있음. 그래서 다른 모드를 사용하는 것이 좋음.

# 3. CBC 모드

## 3.1 CBC 모드란?

- Cipher Block Chaining Mode(암호 블록 연쇄 모드)
- 암호문 블록을 체인처럼 연결시키기 때문에 붙여진 이름
- CBC 모드에서는 1단계의 암호문 블록에 평문 블록을 XOR 연산 후 암호화 수행
- 즉 각각의 암호문 블록은 해당 평문블록 분만 아니라 그 이전의 평문 블록들의 영향도 받게됨

복호화 그림이 좀 이상한데? 아아 복호화 해서 나온 게 아니라 상자 안에서 나오는거네. 정확하게는 상자 안에 들어가기 전에 꺼내야겠지.

## 3.2 초기화 벡터

초기화 벡터(IV: initialization vector) :

- 제일 첫 평문 블록을 암호호활 때
  [1단계 앞의 암호문 블록] 이 존재하지 않으므로 그것을 대신할 한 개의 블록을 준비할 필요가 있음.

## 3.3 CBC 모드의 특징

- 평문 블록은 반드시 [1단계 앞의 암호문 블록]과 XOR 연산 후 암호화
  -> 만약 평문 블록 1과 2의 값이 같은 경우라도 암호문 블록 1과 2의 값이 같아진다고는 할 수 없고(ECB에서는 암호문 블록 1, 2도 같음. 왜지 ??;;), ECB 모드가 갖고 있는 결점이 CBC 모드에는 없음.
- 암호문 블록 3을 만들고 싶다면 적어도 평문 블록 1, 2, 3가 있어야 함.
- ECB 모드 vs. CBC 모드
- 깨진 암호문: 데이터 통신은 안전하지 않음. 100% 신뢰성 통신이 아님. 예를 들어 받아진 암호문이 깨질 수 있음. 한 비트가 에러가 났다거나.
  예를 들어 암호문 블록 2가 깨졌다면 복호화를 했을 때 평문 블록2와 3이 영향을 받음. 즉 CBC 모드에서 암호문 블록 하나가 파손되면 2개의 평문 블록에 영향을 미침.
- 암호문 블록에서 비트 누락시 영향(깨진 것과 다름)
  예를 들어 암호문 블록 2의 비트가 누락되었다면 암호문 블록3과 4가 영향을 받아 결국 평문 블록 2, 3, 4가 영향을 받음 (왜??;;;)
  즉 CBC 모드에서 암호문 블록의 비트 누락이 생기면 해당 평문 블록과 그 이후의 평문 블록 전체에 영향을 미침.

## 3.4 CBC 모드에 대한 공격

- 초기화 벡터의 비트를 반전시켜 평문 블록의 비트를 반전시키는 공격
  -> 첫 번째 평문에 영향을 줌
- 초기화 벡터의 비트반전에 대한 영향

## 3.5 패딩 오라클 공격

- 블록 암호의 패딩을 이용한 공격을 말함( 패딩은 의미 없는 값으로 보통 0이다.)
- 패딩 내용을 조금씩 변화시켜 암호문을 여러차레 송신함 (사람이 하지 않고 소프트웨어를 만들어서 함.)
- 수신자가 올바로 복호화하지 못할 경우의 오류를 관찰하여 평문 정보를 취득함(패딩은 의미없는 값이기 때문에 복호화를 했을 때 될 수도 있고 안될 수도 있음.)
- 패딩을 사용하는 모든 모드들은 이 공격의 대상이 될 수 있음.
- 공격자가 메시지의 패딩이 옳은지 아닌지 여부를 판단하는 오라클이 있다면 이 오라클을 이용해 암호문에 대응하는 메시지를 알아낼 수 있음.
  (이해가 안되는데 ...)

## 3.6 초기화 벡터 공격

- 초기화 벡터는 원래 난수로 부여함.
- SSL/TLS의 TLS 버전 1.0
  (ssl 프로토콜은 웹에서 암호화에 사용함. ssl 3.0 버전을 tls라고 함. 즉 웹 보안에 사용되는 보안 프로토콜이라고 생각하면 됨. 실제로 많이 사용하고 있고 거기에서 실제로 CBC 모드를 사용을 했었는데 그 때 초기화 벡터에 대한 공격이 있었음. 지금은 발견돼서 고쳐졌음.)
  초기화 벡터를 CBC 모드로 암호화한 마지막 블록을 사용함
  문제점 발견 후 TLS 버전 1.1부터는 마지막 블록을 사용하지 않고 난수를 사용함.

## 3.7 CBC 모드 활용의 예

- ssl/tls
- 3DES(트리플 DES)
- AES-256
- IPsec(터널링 기법을 사용하는 기술. 즉 비밀 통로. 가상 사설망 VPN에 사용되는 프로토콜 중 하나)
- 인증에 사용되는 대칭암호 시스템의 하나인 kerberos version 5에서 사용
  즉 CBC 모드는 지금도 상당히 많은 곳에서 사용하고 있는 모드임.

# 4. CFB 모드

## 4.1 CFB 모드란?

- Ciper Feedback Mode
- 1단계 앞의 암호문 블록을 암호 알고리즘의 입력으로 사용함.

## 4.2 초기화 벡터

- 1단계 앞의 출력이 존재하지 않으므로 대신에 IV를 사용
- CBC vs CFB:
  CFB모드에서는 평문이 암호화 알고리즘의 입력값이 아니다.
  CBC에서는 평문을 무언가와 XOR한 값이 암호화 알고리즘의 입력값으로 들어간다.
  CFB 모드에는 키 스트림이 있다.
  CFB에서는 평문과 상관없이 암호 알고리즘의 결과값을 미리 만들어놓을 수 있음. 즉 키 스트림만 미리 준비를 해놓는다면 그것과 비트 바이 비트(스트림 연산)로 연산을 하므로 CBC 보다 속도가 빠름.
  CBC는 암호화 하기까지 시간이 걸림.

## 4.3 CFB 모드와 스트림 암호

- 키 스트림:
  암호 알고리즘이 생성하는 비트열
  키 스트림을 생성하기 위한 의사난수 생성기로서 암호 알고리즘을 이용
  초기화 벡터는 의사난수 생성기의 seed에 해당
- CFB모드는 블록암호를 써서 생성한 키를 이용하는 스트림 암호(마지막 단계가 암호화 알고리즘이 아니라 XOR 연산이라서 그런듯?)

## 4.4 CFB 모드의 복호화

- 블록암호 알고리즘 자체는 복호화가 아닌 암호화에서처럼 암호화를 하고 있다는 것이 다른 모드들과의 차이점임. 즉 복호화 단계에서도 키 스트림이 암호화에 의해 생성됨.

## 4.5 CFB 모드에 대한 공격

- 재전송 공격(replay attack)
  CFB 모드에서만 가능한 공격은 아님.
  정당한 사용자에 의해 사용되는 정당한 데이터를 반복해서 발송하는 공격
  멜로리는 의뢰 메시지(암호문)을 도청해서 모아둠. 어제의 암호문 블록 2~4로 오늘의 암호문 블록 2~4를 대체해서 보냄.
  그러면 암호문 블록 2는 제대로 해독이 안되고 오류가 발생함.
  암호문 블록 3, 4는 해독은 되지만 어제의 평문 블록 3, 4로 해독됨.
  해결 방법 : 메시지 인증 코드(9장) -> 이건 아직 몰라도 됨

# 5. OFB 모드

## 5.1 OFB 모드란?

- Output Feedback Mode
- 암호 알고리즘의 출력을 암호 알고리즘의 입력으로 피드백함
- 평문 블록은 암호 알고리즘에 의해 직접 암호화되고 있는 것이 아님. (CFB와 공통점)
- 즉 평문 블록과 암호 알고리즘의 출력을 XOR해서 암호문 블록을 만듦(CFB와 공통점)

## 5.2 초기화 벡터

- CBC 모드, CFB 모드와의 공통점.
- 초기화 벡터는 랜덤 비트열임.

## 5.3 CFB 모드와 OFB 모드의 비교

CFB는 암호 알고리즘의 입력 값이 암호문 블록, OFB는 암호 알고리즘의 입력 값이 암호 알고리즘의 출력 값임. 즉 CFB와 OFB는 암호 알고리즘으로의 입력만이 다름.
OFB는 CFB 모드와 마찬가지로 키 스트림(암호화 알고리즘의 출력값)을 미리 준비해두면, 암호문을 만들 때 신속히 처리할 수 있음.
따라서 AES등의 암호 알고리즘에 비해 속도가 상당히 빠름

# 6. CTR 모드

- 1씩 증가해가는 카운터를 암호화해서 키 스트림을 만들어내는 스트림 암호
- 블록을 암호화할 때마다 1씩 증가해가는 카운터를 암호화해서 키 스트림을 만듦

## 6.1 카운터 만드는 법

- 카운터 초기값:
  암호화 때마다 다른 값(nonce, 비표, 랜덤함)을 기초로 해서 작성함
  128비트 블록의 예 : 66 6F 6F 6B 20 4D 61 72(비표, 매번 바뀜) 00 00 00 00 00 00 00 01(블록 번호)
  즉, 평문 블록 1용의 카운터 : (비표) + 00 00 00 00 00 00 00 01
  평문 블록 2용의 카운터 : (비표) + 00 00 00 00 00 00 00 02 (CTR + 1)
  평문 블록 3용의 카운터 : (비표) + 00 00 00 00 00 00 00 03 (CTR + 2)
  평문 블록 4용의 카운터 : (비표) + 00 00 00 00 00 00 00 04 (CTR + 3)

## 6.2 OFB 모드와 CTR 모드의 비교

OFB 모드는 다음 블록 암호화를 위해 피드백을 함
CTR 모드는 다음 블록 암호화를 위해 카운터를 1 증가시킴

## 6.3 CTR 모드의 특징

- 암호화와 복호화의 구조가 완전히 같음
- 프로그램으로 구현하는 것이 매우 간단
- 스트림 암호의 특징을 가짐
- 카운터를 비표와 블록 번호로부터 신속하게 구할 수 있기 때문에 블록을 임의의 순서로 암호화, 복호화할 수 있음
- 병렬 처리가 가능한 시스템(속도가 빠름)에서는 CTR 모드를 이용하여 자료를 고속으로 처리 가능

## 6.4 오류와 기밀성

- (복호화 과정 중) 암호문 블록에서 1비트의 반전이 생긴다면:
  반전된 비트에 대응하는 평문 블록의 1비트만 반전되고, 오류는 확대되지 않음.
- 키 스트림의 1블록을 암호화한 결과가 암호화전의 결과와 우연히
  같아졌다고 하면 그 이후 키 스트림은 완전히 같은 값의 반복 (아까 ECB모드에서 블록 1과 2가 같으면 암호문 블록 1과 2도 같은 이유랑 똑같은거같은데?)
- CTR 모드에서는 그런 걱정은 없음

# 7. 모드 선택

각 모드의 특징을 비교

1. ECB 모드:

- 장점 : 간단, 병렬처리 가능, 고속
- 단점 : 평문 속의 반복이 암호문에 반영된다. (ECB모드에서 블록 1과 2가 같으면 암호문 블록 1과 2도 같다는 것과 맥락이 같은듯?), 재전송 공격이 가능.
- 사용하지 않는 것을 권장함

2. CBC 모드:

- ECB 모드의 단점을 보완하기 위해 체인으로 만들었음.
- 단점: 비트 단위의 에러(깨지는거 말하는듯?) 가 있는 암호문을 복호화하면, 대응하는 평문 블록 전체와 다음 평문 블록의 대응하는 비트가 에러가 남.
  복호화만 병렬 처리가 가능하고, 암호화에서는 병렬 처리를 할 수 없다. (이유는 언급안함)
- 사용 권장

3. CFB 모드:

- 장점: 패딩이 필요 없음.
- 단점: 복호화만 병렬처리 가능하다. 재전송 공격이 가능함.

이하 생략

~대충 원리만 알면 되는 부분. 시험에는 나옴~

# CTS 모드

- Cipher Text Stealing
- 마지막 블록 한 단계 전의 암호화 블록(암호와 알고리즘의 출력값?)을 패딩으로 대신 이용함 (일반적인 패딩은 의미없는 값임)
- ECB나 CBC 모드와 조합해서 사용함
- 실제로 사용함

# GCM 모드 (시험에 많이 나옴. 기사시험 말하는 듯?)

G는 사람이름임

- Galois/Counter Mode
- CTR 모드에 인증기능을 추가한 모드
- 지금까지 본 모드들은 인증기능은 없었음
- 기밀성(지금까지의 모드들의 기능) + 인증 -> 사실상 이것만 알면 됨.
- 암호화 입력: 암호키, 평문, Nonce(CTR은 여기까지) + 부가 인증 데이터(ADD)
- 암호화 출력: 암호문, 인증값(tag)

# CCM 모드:

- Counter mode + CBC-MAC(Message Authentication Code, 메시지 인증 코드)
- 메시지의 기밀성 + 인증

즉 GCM, CCM은 인증기능까지 포함한다는 것을 기억하면 됨.

# AEAD(Authenticated Encryption with Associated Data, 관련 데이터로 인증된 암호 방식)

- 인증도 하고 암호화도 한다는 뜻.
- CCM, GCM 모드, signcryption이 AEAD 모드임.
  그 외에도 다른 모드들도 해당함.(다른 장에 나와있음. 외울 필요는 없음.) 단 signcryption(sign(서명, 인증을 위함) + encryption(기밀성))까지는 기억하기.
  나머지는 찾으면 업데이트 해준다고 했음.
