# 1. 키 배송 문제

# 1.1 키 배송 문제란?

키 배송 문제:

- 대칭 암호를 사용할 때는 대칭 키를 사전에 공유해야 함.
- 안전하게 키를 보내는 방법은?

키 배송 문제를 해결하는 방법:

- 키를 사전에 공유한다
- 키 배포 센터 활용
- diffie-hellman 키 교환
- 공개 키 암호를 사용한다

키를 보내버리면 도청자 이브도 복호화가 가능함.

## 1.2 키를 사전에 공유하는 방법

키 사전 공유란?

- 안전한 방법으로 키를 사전에 건네주는 것
- 직접 전달은 안전함
- 이메일/일반메일은 위험
- 인원이 많아지면 관리해야 할 키 수 증가(통신마다 키는 다름)

## 1.3 키 배포 센터 활용

키 배포 센터(key distribution center; KDC)

- 암호 통신 때마다 통신용의 키를 키 배포 센터에 의뢰해서 개인과
  키 배포 센터 사이에서만 키를 사전에 공유
- 키 배포 센터의 역할을 하는 컴퓨터를 지정
- 구성원 전원의 키를 보존
- 키 배포센터를 이용하는 과정

문제점:

- 구성원 수 증가시 키 배포 센터의 부하
- 키 배포 센터의 컴퓨터가 고장시 조직 전체의 암호 통신 마비
- 키 배포센터가 공격의 대상이 될 수 있다

## 1.4 Diffie-Hellman 키 교환 방법

암호학자.diffie와.hellman이 제안한 방법
프로토콜임.

- 암호 통신을 원하는 두 사람이 있다면 어떤 정보를 교환한다
  • 이 정보는 도청자 이브에게 노출 되어도 무방
- 두 사람은 교환한 정보를 가지고 동일한 키를 각각 생성할 수 있다
  • 하지만 도청자 이브는 같은 키를 만들 수 없다
  DLP(이산 대수 문제 ) 이론을 이용

## 1.5 공개 키 암호를 사용하는 방법

- 대칭 암호는 암호와 키 = 복호화 키
- 공개 키 암호:
  - 암호화 키 ≠ 복호화 키
  - 암호화 키는 공개되어 있음. 즉 누구든지 암호화 할 수 있음.
  - 암호화 키를 가지고 있어도 복호화할 수 없음.
  - 복호화 키를 가지고 있어야만 복호화할 수 있음.
- 과정 :
  - 수신자가 미리 암호화 키를 송신자에게 알려줌. 이 암호화 키는 도청자에게 알려져도 무방
  - 송신자는 그 암호화 키를 이용하여 암호화해서 수신자에게 전송
  - 암호문을 복호화할 수 있는 자는 수신자(복호화 키를 가지고 있음) 뿐임.
  - 이렇게 하면 복호화 키를 수신자에게 배송 안해도 됨.
- 공개 키 암호를 이용한 키 배송(세션 키)

# 2. 공개 키 암호

## 2.1 공개 키 암호란?

- 암호화 키 ≠ 복호화 키
- 송신자는 암호화 키를 써서 메시지를 암호화 하고, 수신자는 복호화 키를 써서 암호문을 복호화
- 송신자가 필요한 것은 암호화 키 뿐
- 수신자가 필요한 것은 복호화 키 뿐
- 도청자에게 알려지면 곤란한 것은 복호화 키
- 암호화 키는 도청자에게 알려져도 무방
- 공개 키:
  - 암호화 키가 공개되어도 무방하다는 듯
  - 즉 공개 키가 도청되는 것을 신경 쓸 필요가 없다.
- 개인 키:
  - 복호화 키는 미공개한다는 뜻
  - 다른 사람에게 개인 키를 보여주거나 전달하면 안됨
  - 개인 키는 자신의 통신 상대에게도 보여주면 안됨.
- 키 쌍:
  - 공개 키와 개인 키는 한 쌍임 -> 공개 키로 암호화한 암호문은 그 공개 키와 쌍이 되는 개인 키가 아니면 복호화할 수 없음.
  - 키 쌍을 이루는 2 키들은 서로 밀접한 관계가 있음
  - 공개 키와 개인 키 쌍은 별개로 만들 수 없음 -> 먼소리임?? 개인 키는 공개 키랑 무조건 관련이 있어야 된다는 말인가?
- 공개키 암호의 역사
  - diffie와 hellman
    - 공개 키 암호의 아이디어를 발표
    - 암호화 키와 복호화 키의 분리성
    - 공개 키의 특성 제시
  - merkle와 hellman
    - 배낭 암호 -> 지금은 깨짐. 사용되지 않음.
  - rivest, shamir, adleman
    - 공개 키 암호 알고리즘 RSA 발표함

## 2.2 공개 키를 사용한 통신의 흐름

- 앨리스가 밥에게 메시지 보내기
  (1) 밥은 공개 키/개인 키로 이루어진 한 쌍의 키(KB(pub)/KB(pri)) 생성
  (2) 밥은 자신의 공개 키(KB(pub))를 앨리스에게 전송
  (3) 앨리스는 밥의 공개 키를 써서 메시지(P)를 암호화 (C=E(KB(pub),P))
  (4) 앨리스는 암호문(C)을 밥에게 전송
  (5) 밥은 자신의 개인 키(KB(pri))를 써서 암호문을 복호화
  (P=D(KB(pri),C))

## 2.3 여러 가지 용어

- 대칭 암호 :
  - 동일 키 사용해 암호화와 복호화
  - 암복호화가 거울처럼 대칭
  - 키: 비밀키라고 함.
- 비대칭 암호:
  - 키: 개인 키와 공개 키

## 2.4 공개 키 암호로도 해결할 수 없는 문제

- 공개 키의 인증에 관한 문제:
  - 입수한 공개 키의 진위를 판단할 필요가 있음.
  - 중간자 공격(man-in-the-middle attack) -> RSA 암호를 공격하는 방법. 예를 들면 위장.
- 공개 키 암호의 속도: 대칭 암호보다 처리 속도가 몇백 배 늦음. 따라서 대량의 데이터를 암호화하는 데이는 쓰이지 않음. 예를 들면 키 값의 암호화에 사용됨.

# 3. 정수론

## 3.1 소수와 서로소

- 약수
- 약수의 성질(우리는 증명은 생략, 성질 자체도 빨리 넘어갔음)
- 소수:
  - 정수 p > 1, 약수로 +-1과 +-p만을 가진다면 p는 소수이다.
  - 약수들의 지수 승의 곱으로 어떤 수를 나타낼 수 있음.
- 서로소: 공약수가 1 뿐인 두 수

## 3.2 모듈러 연산

- 합동: a ≡ b(mod n) -> a와 b는 n으로 나눈 나머지가 같다.
- 고속지수연산법 :
  제곱 승을 나누는 것은 (원래 수)를 (나누는 수)로 나눳을 때의 (나머지의 제곱승)을 (나누는 수)로 나눴을 때와 나머지가 같음 (증명 생략)
  7^18 = 7^16 * 7^2 E 7*11 E 1 mod 19  
  답은 1임.

## 3.3 페르마와 오일러의 정리

- 페르마 정리: -> RSA 암호에서 사용함.
  - p가 소수이고 a가 p에 의해 나누어지지 않으면 a^(p-1) ≡ 1(mod p)
  - 증명 생략
  - 이 정리가 나오기 전에는 3.2의 복잡한 과정을 거쳤음. 우리는 이 결과만 가져다 쓸 것임.
  - 페르마 정리의 다른 유용한 형태 :
    만약 p가 소수고 a가 양의 정수라면 a^p ≡ a mod p
    가 성립한다.
    주의! a=10, p=5, 10^5 = 100000 ≡ 10 mod 5 ≡ 0 mod 5
- 오일러 정리:
  오일러의 totient 함수: 정수론에서 오일러의 totient 함수는 (n)라고 표기된다.
  (n): n보다 작고 n과 서로 소인 양의 정수의 개수
  서로소인 모든 a와 n에 대해서
  a^(n) ≡ 1(mod n)
  - 오일러 정리의 추가적인 특성 :
    - 오일러 함수의 특성:
      - 서로소인 모든 a와 n에 대해서 a^((n)+1) ≡ a(mod n)
  - 오일러 함수의 특성:
    - 소수 n에 대해서 (n) = n-1
    - 소수 p와 q에 대해서, n=pq (n: 합성수) (n) = (pq) = (p) x (q) = (p-1)(q-1)

## 3.4 이산 대수 문제(Discrete Logarithm Problem)

- 결론만 알면 됨.
- y = g^x mod p
- 최악의 경우, 반복적인 곱셈과정을 x번 수행해야만 하며(고속지수연산에 해당 안하는 경우), 효율적인 계산을 위한 알고리즘이 존재
- 그렇더라도 g,x,p를 알면 y를 구할 수 있음.
- 반면, y, g, p가 주어지더라도 x를 계산하는 것은 매우 어려움. 작은 수는 추측해서 맞출 수 있지만 그렇지 않은 경우는 어려움. -> 그 어려움은 RSA 알고리즘을 풀기 위해 요구되는 인수분해의 어려움 만큼이나 어려운 문제다.
- 이 정도만 기억하면 됨.

# 4. RSA

# 4.1 RSA란 무엇인가?

- 응용:
  - 공개 키 암호
  - 디지털 서명
  - 키 교환(키 배송 말하는 건가?)

# 4.2 RSA에 의한 암호화

- 평문, 키, 암호문을 숫자로 변환한 뒤에 실행함.
- 암호문 = 평문^E mod N
- (E, N): 공개 키
- 이 쌍을 알면 누구라도 암호화를 행할 수 있음.
- RSA 암호화에 사용되는 키
- E와 N은 면밀한 계산을 통해 생성됨

# 4.3 RSA에 의한 복호화

- 평문 = 암호문^D mod N
- (D, N): 개인 키
- RSA 복호화에 사용되는 키
- D와 N은 면밀한 계산을 통해 생성됨
- E와 D는 밀접한 연관관계

키 쌍:

- 공개 키: (E, N)
- 개인 키: (D, N)
- 암호문 = 평문^E mod N (평문을 E제곱해서 N으로 나눈 나머지)
- 평문 = 암호문^D mod N (암호문을 D제곱해서 N으로 나눈 나머지)

# 4.4 키 쌍의 생성

1. N을 구한다
2. L을 구한다(L은 암복호화가 아니라 키 쌍을 생성할 때만 등장하는 수)
3. E를 구한다
4. D를 구한다

- N 구하기
  - p, q를 임의의 소수로 선택(큰 소수임, 의사 난수 생성기로 구함.)
  - N = p x q
- L 구하기
  - L은 p-1과 q-1의 최소공배수(lcm(p-1, q-1))
- E 구하기
  - 1 < E < L
  - E와 L은 서로소 (gcd(E, L) = 1)
- D 구하기
  - 1 < D < L
  - E x D mod L = 1

# 4.5 구체적 계산

- 225^29 mod 323의 계산

# 5. RSA에 대한 공격

## 5.1 암호문으로부터 평문 구하기

- 암호 해독자가 알고 있는 것
  - 암호문(도청해서 구함)
  - 공개 키 (E, N)
- 암호 해독자가 모르는 것

  - 평문
  - 개인 키 (D, N). 이 중 적어도 D는 모름
  - p, q, L(키 쌍을 만듦)

- 암호문 = 평문^E mod N
  에서 평문을 구하려면 이산 대수 문제를 풀어야 함
  -> 현재까지 아직 이산 대수를 구하는 빠른 방법을 알지 못함

## 5.2 전사 공격

- 평문 = 암호문^D mod N
- D의 후보가 되는 수를 순서대로 모두 시도해서 복호화 해본다
- D의 비트 수가 크면 클수록 어려워진다
- RSA에서는 p와 q의 비트 수로서 512 비트 이상을 사용함
- N은 1024비트 이상
- E나 D는 N과 같은 정도의 크기이므로 D를 찾으려면 1024비트 이상의 전사공격이 필요함
  -> 현실적으로 불가능함

## 5.3 E와 N으로부터 D 구하기

E x D mod L = 1

- L은 lcm(p-1, q-1)이므로 E로부터 D를 계산할 때는 p와 q를 알아야 함
- 암호 해독자는 p와 q를 전혀 모름 (N= pq)
  -> N을 소인수분해 하면 되지 않느냐?
  이게 어려움.( 큰 수를 고속으로 소인수분해 할 수 있는 방법이 발견되면 RSA를 깰 수 있음. 그러나 현재 큰 수의 소인수분해를 고속으로 행하는 방법은 아직 없음. 소인수분해를 간단히 수행하는 방법이 존재하는지의 여부도 아직 모름. 단, p와 q를 추측할 수는 있다. 의사난수 생성기의 품질(이건나중에배움)이 나쁘면 p와 q를 추측할 수 있다. 따라서 난수 생성기가 강력해서 암호 해독자가 추측할 수 없어야 함.)
  따라서 해독자는 D를 구할 수 없음.
  -> RSA의 안전성을 위해 소수 p와 q를 암호 해독자가 모르게 해야함.

### 기타공격 -> 이건 수업에서 언급 안했는데??

## 5.4 중간자 공격

- RSA 암호의 안전성은 중간자 공격을 기반으로 하는 것이 아니라 인수분해의 어려움을 기반으로 함.
- 즉, 중간자 공격과는 관련이 없음.
- 중간자 공격은 RSA를 해독하는 게 아니라 기밀성을 침해하는 공격임.
- 공격자 맬로리가 송신자와 수신자 사이에서 송신자에 대해서는 수신자처럼 , 수신자에 대해서는 송신자처럼 행세하는 공격.

### 중간자 공격 절차

1. 앨리스는 밥의 공개 키 요청
2. 맬로리는 앨리스의 요청을 도청
3. 밥은 자신의 공개 키 KB(pub)을 앨리스에게 전송
4. 맬로리는 밥의 이 메일이 앨리스에게 도달하지 못하게 하고, 밥의 공개 키를 보존
5. 맬로리는 자신의 공개 키 KM(pub)을 앨리스에게 전송
6. 앨리스는 자신의 메시지 P를 맬로리의 공개 키로 암호화. C=E(KM(pub), P)
7. 앨리스는 암호문 C를 밥에게 전송
8. 맬로리는 암호문 C를 갈취해서 자신의 개인 키로 복호화하고 P를 확보. P=D(KM(pri), C))
9. 맬로리는 위조메일 P'를 만들고 밥의 공개 키 KB(pub)로 암호화. C'=E(KB(pub), P') 밥에게 전송
10. 밥은 C'를 자신의 개인 키로 복호화하고 메일 P'를 읽게 됨.

-> 중간자 공격은 지금은 해결됐고 초기에 이런 문제가 있었음.

# 6. 선택 암호문 공격

- 암호문 공격의 종류 [암호 프로토콜]
  암호 해독자가 도청한 암호문 C로부터 평문 P나 비밀키 K를 도출하는 수동적 공격방법

1. Ciphertext Only Attack(암호문 단독 공격)

- 암호 해독자는 C만 갖고있음
- 이것으로부터 평문 P나 키 K를 찾아내는 방법
- C이외에는 아는 게 없으므로 평문 P의 통계적 성질, 문장의 특성 등을 추정하여 해독하는 방법(ex. 빈도분석도 하나의 예가 됨)

2. Known Plaintext Attack(기지 평문 공격)

- 암호 해독자는 일정량의 평문 P에 대응하는 암호문 C를 알고있음
- 암호문 C와 평문 P의 관계로부터 키 K나 평문 P를 추정하여 해독하는 방법

3. Chosen Plaintext Attack(선택 평문 공격)

- 암호 해독자가 사용된 암호기에 접근할 수 있어 평문 P를 선택하여 그 평문 P에 대응하는 암호문 C를 알아냄(즉, 평문과 암호문 쌍들을 알아내서 관계를 분석하는 것.)
- 키 K나 평문 P를 추정하여 암호를 해독하는 방법

4. Chosen Ciphertext Attack(선택 암호문 공격)

- 암호 해독자가 암호 복호기에 접근할 수 있어 암호문 C에 대한 평문 P를 얻어 암호를 해독하는 방법
  (그럼 이건 그냥 해독이 된 거 아니야? 이때는 암호문을 모르는 상황이겠지?)

## RSA-CCA -> RSA가 CCA 공격이라는 문제점이 있었다만 알아두면 됨.

- 복호 오라클 공격을 공격자가 이용할 수 있다고 가정한 공격
- 복호 오라클 : 임의의 데이터를 송신하면 그것을 암호문으로 간주하고 회신(이 경우엔 틀린 암호문을 보냈을 것이므로 어디가 틀렸다 이런거 말해주는 것임)해주는 서비스. 실제 네트워크에서 오류 메시지 반환을 이용하는 공격. 위조 암호문을 여러 차례 전송하여 반환된 오류 메시지나 타이밍 정보를 활용해 평문을 추측함.
- RSA의 경우 선택 암호문 공격으로 약간의 정보를 취득 가능(즉 공격이 가능함)

### RSA-OAEP(Optimal Asymmetric Encryption Padding) -> 이걸로 RSA의 CCA 공격을 해결했다는 걸 알아야 함.

- RSA를 개량해서 선택암호문공격으로부터 안전하게 만든 것
  -> 암호문에 인증 과정을 추가한 방법
  평문 해시 값과 정해진 개수의 0 등으로 만들어진 인증정보를 평문 앞에 추가한 뒤 RSA로 암호화함.
  복호화시 RSA로 복호화한 후에 선두에 올바른 인증정보가 나타나지 않으면 오류로 판정함.
  그림 : 외울 필요 없음
  인증 과정이 추가된 게 중요함.

-->> 4. CCA부터 이해안되지만 그냥 해당 문제 찾아서 풀 수 있는지만 확인해보고 그냥 외우자ㅏㅏㅏㅏ

# 7. 기타 공개키 암호

수식을 외울 필요 x. 참고로 알아두면 됨.
암호가 무엇에 기반을 하는지 알아야 함.
이게 뭔지는 몰라도 들어는 봤어야 함.
ex. 다음 주 성질이 다른 암호 시스템 하나를 고르시오 1번 rsa 2번 elgamal 3번 AES 4번 Rabin 답: AES 혼자 대칭암호여서 AES임.

## 7.1 ElGamal 방식

- ElGamal이 만든 공개 키 알고리즘임
- 이산 대수를 구하는 것이 어렵다는 것(DLP)를 이용
- 암호문의 길이가 평문의 2배가 되어 버린다는 결점이 있음 -> 효율성이 좋진 않음.

그림: 생략.

## 7.2 Rabin 방식

- Rabin이 만든 공개 키 알고리즘임
- 소인수 분해의 어려움을 이용
- e와 d가 고정된 값을 갖는 RSA 암호 시스템으로 간주됨
  (식 몰라도 됨)

## 7.3 타원곡선 암호(elliptic curve cryptography, ECC)

- 타원 곡선 위에 곱셈을 정의하고, 이 곱셈의 역연산이 어렵다는 것을 이용함
- 즉 ECC의 안전성은 타원곡선 대수 문제를 해결하는 어려움에 의존함
- 장점: 훨씬 적은 비트 크기로 동등한 안전성을 제공해주어 많이 사용함
  -> RSA에 비해 키의 비트 수가 적음

# 8. 공개 키 암호에 관한 Q&A

## 8.1 공개 키 암호의 기밀성

Q. 공개 키 암호는 대칭 암호보다 기밀성이 높은가?
A. 답할 수 없다. 키의 비트 길이에 따라 기밀성의 정도는 변화하기 때문.

## 8.2 공개 키 암호와 대칭 암호의 키 길이

Q. 1024 비트 길이의 키를 갖는 공개 키 암호와, 128비트 길이의 키를 갖는 대칭 암호에서는 비트 길이가 긴 공개 키 암호 쪽이 안전한가?
A. 아니다. 공개 키 암호의 키 길이와 대칭 암호의 키 길이는 직접 비교할 수 없다.
그러나 근래 동향은 ppt 96p의 NIST의 암호 강도 비교를 많이 참고함.

- 보안 강도
  112, 128, 192, 256 비트. 뒤로 갈수록 보안 강도가 센 것.
  해당 보안 강도에 필요한 키의 비트 수를 나열한 것.

## 8.3 대칭 암호의 미래

Q. 공개 키 암호가 생겼기 때문에 앞으로 대칭 암호는 사용할 필요가 없는가?
A. 아니다.

- 일반적으로 같은 정도의 기밀성을 갖는 키 길이의 경우, 공개 키 암호는 대칭 암호보다 몇백배나 느림
- 공개 키 암호는 긴 메시지를 암호화하기에는 적합하지 않음
- 즉, 목적에 따라 대칭 암호와 공개 키 암호 두가지를 모두 사용함

## 8.4 RSA와 소수

Q. RSA의 키 쌍을 모두가 자꾸 만들어가면 그 사이 소수가 없어져 버리는 것은 아닐까?
A. 512비트로 표현할 수 있는 소수의 수는 대략 10^150으로 전 우주에 존재하는 원자 수보다 많다.

## 8.5 RSA와 소인수 분해

Q. RSA로 암호화할 때 큰 수를 소인수 분해할 필요가 있는 것인가?
A. 아니다. RSA의 암/복호화에서도, 키 쌍의 생성에서도 큰 수의 소인수분해를 할 필요는 없다. 큰수의 소인수 분해는 암호문 해독 시에만 한다.
Q. RSA를 해독하는 것은 큰 수를 소인수 분해하는 것과 같은 것인가?
A. 같은 것인지 아닌지 아직 모른다.

- 일단 분명한건 소인수분해를 고속으로 할 수 있으면 RSA는 해독됨.
- 그러나 RSA를 해독하려면 소인수분해를 꼭 해야 한다는 것이 증명된 것은 아님
- 소인수 분해를 하지 않아도 해독할 수 있는 방법이 발견될 지도 모른다.

## 8.6 RSA의 비트 길이

Q. 소인수분해 되지 않기 위해서 N은 몇 비트 길이가 필요한가?
A. 아무리 비트 수가 커도 언젠가는 소인수분해된다.

뒷부분은 걍 읽어보면 됨.

### 공개 키 암호 알고리즘 사용 예시

- 공개 키 암호를 적용하여 2035년까지 사용하고자 하는 경우

1. 보안 강도, 공개키/개인키 길이 확인

- 보안 강도: 128비트 이상
  -> NIST의 표 참고하면 됨

2. 공개 키 암호 알고리즘 종류 확인
   RSA 혹은 AES 선택

3. 키 사용기간 설정

### 암호 알고리즘의 안전성 검토
